---
title: "dataCleaning"
format: html
editor: visual
---

```{r}
#| include: false
library(tidyverse)
#devtools::install_github("kaijagahm/vultureUtils")
library(vultureUtils)
library(here)
library(readxl)
library(mapview)
```

```{r}
base::load(here::here("movebankCredentials/pw.Rda"))
MB.LoginObject <- move::movebankLogin(username = "kaijagahm", 
                                      password = pw)
rm(pw)
```

## *Download data*

```{r}
# Set min and max date
minDate <- "2023-12-01 00:00"
maxDate <- "2023-12-07 00:00"

mydata <- vultureUtils::downloadVultures(loginObject = MB.LoginObject,
                                         removeDup = T, 
                                         dfConvert = T, 
                                         quiet = T, 
                                         dateTimeStartUTC = minDate,
                                         dateTimeEndUTC = maxDate)
```

## *Join `Nili_id`s*

```{r}
ww <- read_excel(here("data/raw/whoswho_vultures_20230920_new.xlsx"), 
                 sheet = "all gps tags")
ww_tojoin <- ww %>% select(Nili_id, Movebank_id) %>% distinct() # pull out just the names columns, nothing else, and remove any duplicates

# join by movebank ID
mydata <- left_join(mydata, ww_tojoin, 
                        by = c("local_identifier" = "Movebank_id"))
```

## *Remove invalid periods (hospital etc.)*

```{r}
periods_to_remove <- read_excel(here("data/raw/whoswho_vultures_20230920_new.xlsx"), sheet = "periods_to_remove") %>%
  select(Nili_id, remove_start, remove_end) %>%
  mutate(across(contains("remove"), lubridate::ymd)) %>%
  filter(!is.na(remove_end)) %>%
  # The following steps generate a sequence of days between the start and end date, so we can then join them to the original data
  group_by(Nili_id) %>%
  mutate(dateOnly = map2(remove_start, remove_end, seq, by = "1 day")) %>%
  unnest(cols = c(dateOnly)) %>%
  select(Nili_id, dateOnly) %>%
  mutate(remove = T)

removal_annotated <- mydata %>%
  mutate(dateOnly = lubridate::date(timestamp)) %>%
  left_join(periods_to_remove, by = c("Nili_id", "dateOnly"))

removed_periods <- removal_annotated %>%
  filter(is.na(remove)) %>%
  sf::st_as_sf(coords = c("location_long", "location_lat"), crs = "WGS84", remove = F)
```

## *GPS jamming filter*

```{r}
jamPolygons <- sf::st_read(here("data/raw/GPS_jamming_3.kml"))

# Visualize the jam polygons with the points on top
mapview(jamPolygons, col.regions = "red") + 
  mapview(removed_periods, col.regions = "blue", color = "blue", cex = 3, alpha = 0.5)

# Remove points that fall into the jam polygons
removed_jammed <- gpsJamFilter(dataset = removed_periods, mask = jamPolygons,
                               longCol = "location_long", 
                               latCol = "location_lat", idCol = "Nili_id")

# and now visualize the after
mapview(jamPolygons, col.regions = "red") +
  mapview(removed_jammed, col.regions = "skyblue", color = "skyblue", cex = 3, alpha = 0.5)
```

## *Data cleaning*

```{r}
cleaned <- cleanData(dataset = removed_jammed,
                     precise = F, 
                     longCol = "location_long",
                     latCol = "location_lat",
                     idCol = "Nili_id",
                     report = F)

cleaned_precise <- cleanData(dataset = removed_jammed,
                             precise = T,
                             longCol = "location_long",
                             latCol = "location_lat",
                             idCol = "Nili_id",
                             report = F)

dim(removed_jammed)
dim(cleaned)
dim(cleaned_precise)
```

## *Remove time spent in capture cages*

```{r}
# Get roosts (for the purposes of capture cage assignment)
roosts <- vultureUtils::get_roosts_df(cleaned, 
                                     id = "Nili_id")

# Load information about capture sites
capture_sites <- read.csv(here::here("data", "raw", "capture_sites.csv"))
load(here::here("data", "dataPrep", "roosts0.Rda"))
AllCarmelDates <- read.csv(here::here("data", "raw", "all_captures_carmel_2010-2021.csv"))

removeCaptures <- function(data, roosts, captureSites, distance = 500){
  # Identify the period of time during which the capture sites are open (when we need to do this exclusion)
  start.day <- 01
  start.month <- 08
  end.day <- 30
  end.month <- 11
  
  # Get roosts that fall in the capture period
  sub.roosts <- roosts %>%
    mutate(start_date = lubridate::dmy(paste(start.day, start.month,
                                      lubridate::year(date), sep = "-")),
           end_date = lubridate::dmy(paste(end.day, end.month, 
                                           lubridate::year(date), sep = "-"))) %>%
    filter(date >= start_date & date <= end_date)
  
  if(nrow(sub.roosts) > 0){
    # Calculate the roost distance to each of the capture cages. If it is less than 500m, keep that line.
  crds <- matrix(c(sub.roosts$location_long, sub.roosts$location_lat),
                 nrow = nrow(sub.roosts), ncol = 2) # roost locs as simple lat/long coords
  distanceMat <- matrix(ncol = nrow(captureSites),
                        nrow = nrow(crds))
  colnames(distanceMat) <-  unique(captureSites$name)
  
  for(i in 1:nrow(crds)){
    distanceMat[i,] <- round(geosphere::distm(crds[i,], 
                                              captureSites[,c(3,2)]), 2)
    }
  }
  
  closestCaptureSite <- colnames(distanceMat)[apply(distanceMat, 1, which.min)] # ID of closest capture site
  closestCaptureDist <- apply(distanceMat, 1, min) # distance from closest capture site
  
  sub.roosts <- cbind(sub.roosts, closestCaptureSite, closestCaptureDist)
  sub.roosts$captured <- ifelse(sub.roosts$closestCaptureDist <= distance, T, F)
  sub.captured.dates <- sub.roosts %>% 
    filter(captured) %>%
    select(Nili_id, date, closestCaptureSite, 
           closestCaptureDist, captured)
  # XXX START HERE
  
  
  
  
}

## For Carmel--different protocol.
sub.captured.no.carmel <- subset(sub.captured.dates, ClosestCaptureSite != "Carmel")
sub.captured.carmel <- subset(sub.captured.dates, ClosestCaptureSite == "Carmel")

AllCarmelDates$Date <- as.Date(AllCarmelDates$Date, format = "%d/%m/%Y")

AllCarmelDates.1 <- data.frame(Date = as.Date(paste(AllCarmelDates$Date-1)))
AllCarmelDates.2 <- data.frame(Date = as.Date(paste(AllCarmelDates$Date-2)))
AllCarmelDates.3 <- data.frame(Date = as.Date(paste(AllCarmelDates$Date-3)))

AllCarmelDates.all <- rbind(AllCarmelDates, AllCarmelDates.1, AllCarmelDates.2, AllCarmelDates.3)

sub.captured.carmel <- sub.captured.carmel %>%
  mutate(known_capture = ifelse(date %in% AllCarmelDates.all$Date, 1, 0),
         Captured = ifelse(known_capture == 1 & ClosestCaptureDist <= 50, "yes", "no")) %>%
  filter(Captured == "yes") %>%
  dplyr::select(-c(known_capture))

names(sub.captured.no.carmel)
names(sub.captured.carmel)

sub.captured.dates <- rbind(sub.captured.no.carmel, sub.captured.carmel)

# We also need to exclude the day after the bird was captured
sub.captured.dates.1 <- sub.captured.dates
sub.captured.dates.1$date <- sub.captured.dates.1$date+1

sub.captured.dates <- rbind(sub.captured.dates, sub.captured.dates.1)
sub.captured.dates <- sub.captured.dates %>%
  dplyr::distinct(Nili_id, date, .keep_all = T)

# It all looks ok, so we can subset the dataset to exclude the capture dates
removed_captures <- removed_periods %>%
  left_join(sub.captured.dates, by = c("Nili_id", "dateOnly" = "date"))
nrow(removed_periods) == nrow(removed_captures) # should be TRUE. NOW we can filter.
removed_captures <- removed_captures %>%
  dplyr::filter(Captured != "Yes"|is.na(Captured)) # remove the individual*days when they were captured

# How many rows and individuals did we remove?
before <- nrow(removed_periods)
after <- nrow(removed_captures)
(propChange <- (before-after)/before) # approx. 1% of data removed.
length(unique(removed_periods$Nili_id)) == length(unique(removed_captures$Nili_id)) # no change in number of individuals! As expected.
```
