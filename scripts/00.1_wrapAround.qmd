---
title: "Wrap Around"
format: html
editor: visual
---

```{r}
library(tidyverse)
library(here)
library(future)
source(here("scripts/00.0_functions.R"))
roostPolygons <- sf::st_read(here("data/raw/roosts50_kde95_cutOffRegion.kml"))
```

## Load data

```{r}
load(here("data/dataPrep/downsampled_10min_forSocial.Rda"))
```

It's completely not computationally tractable to first make the entire dataset with 100 replicates and then calculate networks on it. Instead, we're going to have to iterate through, do each one, calculate the networks on each one, calculate the metrics, and save those.

```{r}
# prepare the data
downsampled_10min_forSocial <- map(downsampled_10min_forSocial, ~{
  .x %>% mutate(time = substr(as.character(timestamp), 12, 19))
})

roosts <- map(downsampled_10min_forSocial, ~{
  vultureUtils::get_roosts_df(.x, id = "Nili_id") %>%
    sf::st_as_sf(., crs = "WGS84", coords = c("location_long", "location_lat"), remove = F)
})
```

```{r}
fn <- function(dataset, rst, iter){
  # rotate data
  #message("rotating")
  rotated <- rotate_data_table(dataset = dataset, shiftMax = shiftMax, 
                               idCol = "Nili_id", dateCol = "dateOnly",
                               timeCol = "time") %>% 
    mutate(timestamp = newdatetime) %>%
    sf::st_as_sf(., coords = c("location_long", "location_lat"), remove = F, crs = "WGS84")
  verts <- unique(rotated$Nili_id)
  
  tojoin_roosts <- rotated %>% st_drop_geometry() %>% 
    select(Nili_id, "roost_date" = dateOnly, newDate) %>% distinct()
  roosts_temp <- rst %>%
    left_join(tojoin_roosts, by = c("Nili_id", "roost_date")) %>%
    mutate(roost_date = newDate)
  vertsr <- unique(roosts_temp$Nili_id)
  
  # calculate sri for rotated data
  #message("calculating sri")
  fl <- vultureUtils::getFlightEdges(rotated, roostPolygons = roostPolygons,
                                     distThreshold = 1000, idCol = "Nili_id",
                                     return = "sri") %>% 
    mutate(sri = replace_na(sri, 0)) %>%
    filter(sri != 0)
  fe <- vultureUtils::getFeedingEdges(rotated, roostPolygons = roostPolygons,
                                      distThreshold = 50, idCol = "Nili_id",
                                      return = "sri") %>%
    mutate(sri = replace_na(sri, 0)) %>%
    filter(sri != 0)
  ro <- vultureUtils::getRoostEdges(roosts_temp, mode = "distance",
                                    distThreshold = 100, latCol = "location_lat",
                                    longCol = "location_long", idCol = "Nili_id",
                                    dateCol = "roost_date", return = "sri") %>%
    mutate(sri = replace_na(sri, 0)) %>%
    filter(sri != 0)
  
  # make graph from sri
  #message("making graph")
  g_fl <- igraph::graph_from_data_frame(d = fl %>% mutate(weight = sri), 
                                        directed = FALSE, vertices = verts)
  g_fe <- igraph::graph_from_data_frame(d = fe %>% mutate(weight = sri), 
                                        directed = FALSE, vertices = verts)
  g_ro <- igraph::graph_from_data_frame(d = ro %>% mutate(weight = sri), 
                                        directed = FALSE, vertices = vertsr)
  
  
  # calculate graph metrics
  #message("calculating metrics")
  graph_metrics <- data.frame(degree = degree(g_fl),
                              strength = strength(g_fl),
                              Nili_id = names(degree(g_fl)),
                              situ = "flight") %>%
    bind_rows(data.frame(degree = degree(g_fe),
                         strength = strength(g_fe),
                         Nili_id = names(degree(g_fe)),
                         situ = "feeding")) %>%
    bind_rows(data.frame(degree = degree(g_ro),
                         strength = strength(g_ro),
                         Nili_id = names(degree(g_ro)),
                         situ = "roosting")) %>%
    mutate(rep = iter)
  row.names(graph_metrics) <- NULL
  
  # save graph metrics to spot in list
  return(graph_metrics)
}

reps <- 100
shiftMax <- 1
```

Now actually do the thing

```{r}
future::plan(future::multisession, workers = 15)
metrics_seasons <- vector(mode = "list", length = length(downsampled_10min_forSocial))
for(i in 1:length(downsampled_10min_forSocial)){
  cat("Working on season ", i)
  dat <- downsampled_10min_forSocial[[i]]
  rst <- roosts[[i]]
  metrics_seasons[[i]] <- suppressWarnings(furrr::future_map(1:reps, ~fn(dataset = dat, 
                                                        rst = rst, iter = .x),
                              .progress = T))
}

for(i in 1:length(metrics_seasons)){
  metrics_seasons[[i]] <- purrr::list_rbind(map2(metrics_seasons[[i]], 1:reps, ~.x %>% mutate(rep = .y))) %>% mutate(seasonUnique = season_names[i])
}
metrics_wrapped <- purrr::list_rbind(metrics_seasons)
metrics_wrapped <- metrics_wrapped %>%
  group_by(seasonUnique, situ, rep) %>%
  mutate(n = length(unique(Nili_id)))
save(metrics_wrapped, file = here("data/metrics_wrapped.Rda"))
```

```{r}
load(here("data/metrics_wrapped.Rda"))
metrics_wrapped <- metrics_wrapped %>%
  group_by(seasonUnique, situ, rep) %>%
  mutate(normDegree = degree/(n-1),
         normStrength = strength/sum(strength, na.rm = T))

load(here("data/calcSocial/networkMetrics.Rda"))

allMetrics <- networkMetrics %>% select(season, "situ" = type, Nili_id, normDegree, normStrength)%>% left_join(metrics_wrapped %>% select("season" = seasonUnique, situ, Nili_id, rep, "wrapped_normDegree" = normDegree, "wrapped_normStrength" = normStrength)) %>%
  mutate(Nili_id = factor(Nili_id))

# See an example of the deviations for 10 random vultures
set.seed(3)
vultures <- sample(allMetrics$Nili_id, size = 15)
allMetrics %>% filter(season == "2023_summer", Nili_id %in% vultures) %>%
  ggplot(aes(x = Nili_id, y = wrapped_normDegree))+
  geom_violin()+
  geom_point(aes(x = Nili_id, y = normDegree), col = "firebrick2", size = 2)+
  facet_wrap(~situ, scales = "free")+
  theme(axis.text.x = element_blank(), 
        axis.ticks.x = element_blank())
```

```{r}
metrics_summary <- allMetrics %>%
  group_by(season, situ, Nili_id) %>%
  summarize(normDegree = normDegree[1],
            normStrength = normStrength[1],
            diff_deg = normDegree[1]-mean(wrapped_normDegree, na.rm = T),
            diff_str = normStrength[1]-mean(wrapped_normStrength, na.rm = T),
            sd_deg = sd(wrapped_normDegree, na.rm = T),
            sd_str = sd(wrapped_normStrength, na.rm = T)) %>%
  mutate(z_deg = diff_deg/sd_deg,
         z_str = diff_str/sd_str)

save(metrics_summary, file = here("data/metrics_summary.Rda"))
```

Compare z scores to observed degree and strength values

```{r}
metrics_summary %>%
  filter(!is.infinite(z_deg)) %>%
  ggplot(aes(x = normDegree, y = z_deg, col = situ))+
  geom_point()+
  geom_smooth(method = "lm")+
  theme_minimal()+
  facet_wrap(~season, scales = "free")

metrics_summary %>%
  filter(!is.infinite(z_str)) %>%
  ggplot(aes(x = normDegree, y = z_str, col = situ))+
  geom_point()+
  geom_smooth(method = "lm")+
  theme_minimal()+
  facet_wrap(~season, scales = "free")
```

Interesting that for co-roosting, the relationship between degree and z-score doesn't look the same. Maybe just because the co-roosting distributions are so incredibly left-skewed that everything gets thrown off by the few points that have a lower normDegree? Anyway, what matters is that we are now getting normal z-scores for roosting, not just 0 and 1.

Let's look at the z-score distributions to see if we'll have to change our modeling method or not.

```{r}
metrics_summary %>%
  ggplot(aes(x = z_deg, group = interaction(season, situ), col = situ))+
  geom_density() # these look decently normally distributed, so we should be okay modeling normally.

metrics_summary %>%
  ggplot(aes(x = z_str, group = interaction(season, situ), col = situ))+
  geom_density() # Likewise, nice! Seems like we may be able to model with a gaussian for this one too, which is nice.

# Those distributions are totally different from modeling the normalized degree in absolute terms:
metrics_summary %>%
  ggplot(aes(x = normDegree, group = interaction(season, situ), col = situ))+
  geom_density()

metrics_summary %>%
  ggplot(aes(x = normStrength, group = interaction(season, situ), col = situ))+
  geom_density()

# they're measuring different things. Normalized degree directly measures how many others an individual interacts with, while degree z-score models how much an individual deviates from the normalized degree it would have achieved just by change.
```
