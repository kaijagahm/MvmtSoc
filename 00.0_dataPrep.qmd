---
title: "Data Prep"
format:
  html:
    embed-resources: true
editor: visual
---

## Goals

Prepare data for the movement/social analysis

## Setup

```{r load-packages}
library(vultureUtils)
library(sf)
library(tidyverse)
library(move)
library(feather)
library(readxl)
library(elevatr)
```

## Download data from Movebank

### Authenticate to Movebank

```{r}
base::load("movebankCredentials/pw.Rda")
MB.LoginObject <- move::movebankLogin(username = "kaijagahm", password = pw)
rm(pw)
```

### INPA data

Data collected by Ohad Hatzofe and team with GPS loggers deployed for their study.

Inputs:

-   `MB.LoginObject`

Outputs:

-   `inpadf_touse`

-   `data/derived/inpadf_touse.feather`

```{r download-inpa}
#| eval: false
# inpa <- move::getMovebankData(study = 6071688, login = MB.LoginObject, removeDuplicatedTimestamps = TRUE)
# inpadf <- methods::as(inpa, "data.frame")
# inpadf_touse <- inpadf %>%
#   mutate(dateOnly = lubridate::ymd(substr(timestamp, 1, 10)),
#          year = as.numeric(lubridate::year(timestamp))) %>%
#   filter(lubridate::ymd(dateOnly) >= lubridate::ymd("2020-09-01"), lubridate::ymd(dateOnly) <= lubridate::ymd("2023-05-15")) # cut this off at the same point as the ornitela data
# write_feather(inpadf_touse, "data/derived/inpadf_touse.feather")

length(unique(inpadf_touse$trackId)) # 77
```

### Ornitela data

Inputs:

-   `MB.LoginObject`

Outputs:

-   `dat`

-   `data/derived/dat.feather`

```{r download-ornitela}
#| eval: false
# Ornitela: download data from movebank (just a subset of the times for now)
minDate <- "2020-09-01 00:00"
maxDate <- "2023-05-15 11:59"
# dat <- vultureUtils::downloadVultures(loginObject = MB.LoginObject, removeDup = T, dfConvert = T, quiet = T, dateTimeStartUTC = minDate, dateTimeEndUTC = maxDate)
# write_feather(ornitela, "data/derived/dat.feather")

length(unique(dat$trackId)) # 127
```

## Join INPA and Ornitela data

*Inputs:*

-   `data/derived/inpadf_touse.feather`

-   `data/derived/dat.feather`

*Outputs:*

-   `dat3`

```{r join-inpa-ornitela}
#| eval: false

inpadf_touse <- read_feather("data/derived/inpadf_touse.feather")
dat <- read_feather("data/derived/dat.feather")
# # Will there be a problem joining these?
# names(dat)[!(names(dat) %in% names(inpadf_touse))] # all names in "dat" are found in inpadf_touse
# names(inpadf_touse)[!(names(inpadf_touse) %in% names(dat))] # many are not found in "dat" that are found in inpadf_touse.
# 
# # Add the dataset names so we can keep track of where the data comes from
# inpadf_tojoin <- inpadf_touse[,names(dat)] %>%
#   mutate(dataset = "inpa")
# dat <- dat %>%
#   mutate(dataset = "ornitela")
# 
# # Join the two datasets
# joined <- bind_rows(inpadf_tojoin, dat)
# dim(joined)
# 
# ## fix trackId
# dat2 <- joined %>%
#   mutate(trackId = as.character(trackId),
#          trackId = case_when(trackId == "E03" ~ "E03w",
#                              TRUE ~ trackId))
# # number of unique individuals
# length(unique(dat2$trackId)) # 206
# 
# # Add the Nili_id
# ww <- read_excel("data/raw/whoswho_vultures_20230315_new.xlsx", sheet = "all gps tags")[,1:35] %>%
#   dplyr::select(Nili_id, Movebank_id) %>%
#   distinct()
# 
# # Are there any other individuals who have two different associated trackId's?
# ww %>% filter(Movebank_id %in% dat2$trackId) %>% dplyr::select(Nili_id, Movebank_id) %>% distinct() %>% group_by(Nili_id) %>% summarize(n = length(unique(Movebank_id))) %>% arrange(desc(n)) # Note that there is one Nili_id in our dataset that has two associated trackId's--it's yomtov.
# ww %>% filter(Nili_id =="yomtov") # Y26 and Y26b. So we should expect to once again "lose" an individual once we change to Nili ID's
# 
# all(dat2$trackId %in% ww$Movebank_id) # false.
# 
# # Okay, let's investigate the ones that aren't included
# dat2 %>%
#   filter(!(trackId %in% ww$Movebank_id)) %>%
#   pull(trackId) %>% unique() # looks like this is going to be an issue of character matching. Let's transform everything to lowercase and remove all characters and spaces
# 
# dat2$trackId <- str_replace_all(tolower(dat2$trackId), "\\.", "")
# ww$mb_id <- str_replace_all(tolower(ww$Movebank_id), "\\s|\\(|\\)|\\>", "") %>% str_replace_all(., "whiite", "white")
# 
# sort(unique(ww$mb_id))
# unique(dat2$trackId)[!(unique(dat2$trackId) %in% ww$mb_id)]
# dat2$trackId[dat2$trackId == "y01t60w"] <- "t60white"
# dat2$trackId[dat2$trackId == "e86white"] <- "e86"
# unique(dat2$trackId)[!(unique(dat2$trackId) %in% ww$mb_id)]
# # Investigate the remaining ones:
# dat2 %>% filter(!(trackId %in% ww$mb_id)) %>% dplyr::select(dateOnly, trackId, local_identifier, ring_id, dataset) %>% group_by(trackId, local_identifier, ring_id, dataset) %>% summarize(earlyDate = min(dateOnly)) # okay, looks like these three come from the INPA dataset and haven't been entered into the who's who yet.
# # I guess for now let's just make their trackId's into Nili_id's
# 
# dat3 <- left_join(dat2, ww %>% dplyr::select(mb_id, Nili_id) %>% distinct(),
#                   by = c("trackId" = "mb_id"))
# nrow(dat3) == nrow(dat2) # good, same number of rows. (check that the join worked)
# length(unique(dat3$Nili_id))
# # For any that didn't get Nili_ids assigned, make it the trackId
# dat3 %>% filter(is.na(Nili_id)) %>% pull(trackId) %>% unique() # as expecfted.
# dat3 <- dat3 %>%
#   mutate(Nili_id = case_when(is.na(Nili_id) ~ trackId,
#                              TRUE ~ Nili_id))
# unique(dat3$Nili_id)
```

## Remove invalid periods

Removing known invalid periods, such as times when the vultures were in the hospital or the tags were known not to be attached to birds. These times are derived from a separate Excel sheet.

*Inputs:*

-   `data/raw/whoswho_vultures_20230315_new.xlsx`

-   `dat3`

*Outputs:*

-   `datAnnot`

```{r remove-hospital}
#| eval: false

## annotate the data with periods to remove
toRemove <- read_excel("data/raw/whoswho_vultures_20230315_new.xlsx", sheet = "periods_to_remove")

toRemove <- toRemove %>%
  dplyr::select(Nili_id,
                remove_start,
                remove_end,
                reason) %>%
  mutate(across(c(remove_start, remove_end), .fns = function(x){
    lubridate::ymd(x)
  })) %>%
  dplyr::filter(!is.na(remove_end))

toRemove_long <- toRemove %>%
  group_by(Nili_id, reason) %>%
  # sequence of daily dates for each corresponding start, end elements
  dplyr::mutate(dateOnly = map2(remove_start, remove_end, seq, by = "1 day")) %>%
  # unnest the list column
  unnest(cols = c(dateOnly)) %>%
  # remove any duplicate rows
  distinct() %>%
  dplyr::select(-c(remove_start, remove_end)) %>%
  rename("status" = reason)

# Join to the original data
datAnnot <- dat3 %>%
  left_join(toRemove_long, by = c("Nili_id", "dateOnly")) %>%
  mutate(status = replace_na(status, "valid"))
nrow(datAnnot) == nrow(dat3) #T: good, same number of rows.

# Actually REMOVE the periods to remove...
datAnnot <- datAnnot %>%
  filter(status == "valid")
nrow(datAnnot)
length(unique(datAnnot$Nili_id))
nrow(dat3)
nrow(datAnnot)
```

## Identify and remove capture cage periods

This is Marta's code for identifying periods when the vultures were in the capture cages and removing days of data around those occasions.

*Inputs:*

-   `datAnnot`

*Outputs:*

-   `roosts`

-   `data/derived/roosts.Rda`

```{r}
#| eval: false

# Identify and remove capture dates using Marta's code --------------------
## To identify the capture dates, first we need to classify the roosts (now using the get_roosts() function). Then, if the bird roosted within 500 m of the capture site, it was considered to be captured and that day, and the following day, are excluded from the dataset. This has been validated. Note: this protocol doesn't work for the Carmel because of the position of the roost sites relative to cages. But we're just dealing with southern individuals, so that's okay.
# roosts <- get_roosts_df(df = datAnnot, id = "Nili_id", timestamp = "timestamp", x = "location_long", y = "location_lat", ground_speed = "ground_speed", speed_units = "m/s", quiet = F)
# save(roosts, file = "data/derived/roosts.Rda")
load("data/derived/roosts.Rda")

# Identify the period of time during which the capture sites are open (when we need to do this exclusion)
start.day <- 01
start.month <- 08
end.day <-  30
end.month <- 11
distance <- 500 # distance, in meters, to calculate from the cage

# Load the information about the capture sites
sites <- read.csv("data/raw/capture_sites.csv")

# Subset the roost dataset with the start and end dates for the capture period
sub.roosts <- roosts %>%
  mutate(start_date = as.Date(paste(start.day, start.month, lubridate::year(date), sep="-"),
                              format="%d-%m-%Y"),
         end_date = as.Date(paste(end.day, end.month, lubridate::year(date), sep="-"),
                            format="%d-%m-%Y")) %>%
  filter(date >= start_date & date <= end_date)

unique(lubridate::month(sub.roosts$date)) # now only includes the fall months, which is the capture season.

# then we need to calculate the roost distance to each of the capture cages. if it is less than 500m, keep that line
crds <- matrix(c(sub.roosts$location_long, sub.roosts$location_lat),
               nrow = nrow(sub.roosts), ncol = 2) # get roost locations as simple lat/long coordinates

DistanceMat <- matrix(ncol = nrow(sites), nrow = nrow(crds))
colnames(DistanceMat) <- unique(sites$name)

for(i in 1:nrow(crds)){ # for each roost point...
  DistanceMat[i,] <- round(geosphere::distm(crds[i,], sites[,c(3,2)]), 2) # calculate distance using geosphere::distm
  #print(i)
}

ClosestCaptureSite <- colnames(DistanceMat)[apply(DistanceMat,1,which.min)] # ID of closest capture site
ClosestCaptureDist <- apply(DistanceMat,1,min) # Distance from closest capture site

sub.roosts <- cbind(sub.roosts, ClosestCaptureSite, ClosestCaptureDist)
sub.roosts$Captured <- ifelse(sub.roosts$ClosestCaptureDist <= distance, "Yes", "No")

sub.captured <- subset(sub.roosts, Captured == "Yes") # get list of dates which the bird was inside the cage

sub.captured.dates <- subset(sub.captured,
                             select = c("Nili_id",
                                        "date",
                                        "ClosestCaptureSite",
                                        "ClosestCaptureDist",
                                        "Captured"))

## This, however, does not work for the Carmel, because the roosts are within 500m of the cage and very often the birds roost on top of the cage without actually being inside it. So for the Carmel captures, we will use another protocol: if the birds were sleeping within 50m of the cage and it was a capture day (or 3 days before the release day), we consider the birds were captured and we remove the data

sub.captured.no.carmel <- subset(sub.captured.dates, ClosestCaptureSite != "Carmel")
sub.captured.carmel <- subset(sub.captured.dates, ClosestCaptureSite == "Carmel")

AllCarmelDates <- read.csv("data/raw/all_captures_carmel_2010-2021.csv")
AllCarmelDates$Date <- as.Date(AllCarmelDates$Date, format = "%d/%m/%Y")

AllCarmelDates.1 <- data.frame(Date = as.Date(paste(AllCarmelDates$Date-1)))
AllCarmelDates.2 <- data.frame(Date = as.Date(paste(AllCarmelDates$Date-2)))
AllCarmelDates.3 <- data.frame(Date = as.Date(paste(AllCarmelDates$Date-3)))

AllCarmelDates.all <- rbind(AllCarmelDates, AllCarmelDates.1, AllCarmelDates.2, AllCarmelDates.3)

sub.captured.carmel <- sub.captured.carmel %>%
  mutate(known_capture = ifelse(date %in% AllCarmelDates.all$Date, 1, 0),
         Captured = ifelse(known_capture == 1 & ClosestCaptureDist <= 50, "yes", "no")) %>%
  filter(Captured == "yes") %>%
  dplyr::select(-c(known_capture))

names(sub.captured.no.carmel)
names(sub.captured.carmel)

sub.captured.dates <- rbind(sub.captured.no.carmel, sub.captured.carmel)

# We also need to exclude the day after the bird was captured
sub.captured.dates.1 <- sub.captured.dates
sub.captured.dates.1$date <- sub.captured.dates.1$date+1

sub.captured.dates <- rbind(sub.captured.dates, sub.captured.dates.1)
sub.captured.dates <- sub.captured.dates %>%
  dplyr::distinct(Nili_id, date, .keep_all = T)

# It all looks ok, so we can subset the dataset to exclude the capture dates
datAnnot_noCaptures <- datAnnot %>%
  left_join(sub.captured.dates, by = c("Nili_id", "dateOnly" = "date"))
nrow(datAnnot) == nrow(datAnnot_noCaptures) # should be TRUE. NOW we can filter.
datAnnot_noCaptures <- datAnnot_noCaptures %>%
  dplyr::filter(Captured != "Yes"|is.na(Captured)) # remove the individual*days when they were captured

# How many rows and individuals did we remove?
before <- nrow(datAnnot)
after <- nrow(datAnnot_noCaptures)
(propChange <- (before-after)/before) # approx. 1% of data removed.
length(unique(datAnnot$Nili_id)) == length(unique(datAnnot_noCaptures$Nili_id)) # no change in number of individuals! As expected.

datAnnot_noCaptures <- datAnnot_noCaptures %>%
  dplyr::select(-c("ClosestCaptureSite", "ClosestCaptureDist", "Captured"))
```
